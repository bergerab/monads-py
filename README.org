* Monads
An implementation of several functors, applicative functors, and
monads in Python.

Each supported monad has a ~bind~ method, ~lift~ method (like
~return~), ~app~ method (like ~<*>~), and an ~fmap~ method. Also for monads
that have helper functions I've included a few of them too (such as
~local~ for the Reader monad).

This code takes a little effort to use in real-world code for a few reasons.

First, there's no do-notation so ~lambda~  and
~bind~ must be used instead. 

Second, Python's eager evaluation makes it
cumbersome to write a monad without it running immediately. For
example, to make a IO action that takes input and adds an exclaimation
point, you can't assign it to a variable.

#+BEGIN_SRC python
  io_yell_input = io_input() \
      .bind(lambda x: IO.lift(x + '!')).run()
#+END_SRC

This happens even if the ~run()~ call is removed -- if that is missing it will run
each action but the last). For the IO monad this is because bind is
~f(self.run()))~. Meaning the last in a chain of ~bind~ would never get
~run()~ called. But the ~bind~ chain would run, because Python eagerly evaluates.

The code above will ask for input immediately, instead of creating an
IO action that when run asks for input.

You'll have to wrap it in a function.

#+BEGIN_SRC python
  def io_yell_input():
      return io_input() \
	  .bind(lambda x: IO.lift(x + '!')).run()
#+END_SRC

Third, the lack of curried functions in Python as a
default makes Applicative Functors less useful. Here is a basic
example of what you can do in Haskell:

#+BEGIN_SRC haskell
(+) <$> (Just 2) <*> (Just 4)
#+END_SRC

The Python counterpart would only work if you wrote a curried ~plus~ function:

#+BEGIN_SRC python
  def plus(a):
      def inner_plus(b):
	  return a + b
      return inner_plus

  Just(2).fmap(plus).app(Just(4))
#+END_SRC

* Installation
To install, navigate to the root directory and run:
#+BEGIN_SRC shell
pip3 install .
#+END_SRC

* Usage
** IO
The IO monad provides several helper functions:
- io_print :: a -> IO ()
  - Prints the given value (no added newline)
- io_println :: a -> IO ()
  - Prints the given value and adds a newline at the end
- io_write :: Handle -> String -> IO ()
  - Writes a string to a file handle
- io_close :: Handle -> IO ()
  - Closes a file handle
- io_input :: IO String
  - Asks for input from stdin (uses ~input()~)
- io_open :: FilePath -> IOMode -> IO Handle
  - where FilePath and IOMode = String
  - Opens a file handle for a file at file path FilePath with IOMode
    read/write permissions (uses ~open(...)~).

Because Python uses eager evaluation, any IO action you create is run
immediately. You can put the action in a function to delay its
evaluation. Make sure to add a ~run()~ call to the end of your action
when it is evaluated, otherwise the last IO action in the IO action
will not be called. In Haskell you never have to run a ~run()~ function
because the program is made up of a ~IO ()~ called ~main~ at the
top-level. But this code doesn't enforce some sort of ~io_main~ that you
must assign, instead you have to run the IO monad yourself.

Below is a program that asks the user to enter text, and writes that
text with an exclamation point into a file in the same directory
called ~test_file.txt~.
#+BEGIN_SRC python
  from monad.io import io_print, io_close, io_write, io_open, io_input

  io_print('Enter some text: ') \
  .then(io_input()) \
      .bind(lambda text: io_open('test_file.txt', 'w') \
	    .bind(lambda handle: io_write(handle, text + '!') \
		  .then(io_close(handle)) \
		  .then(io_print('Done')))).run()
#+END_SRC
** Maybe
Uses classes ~Just~ and ~Nothing~. ~return~ can be used via  ~Maybe.lift~. 

Below is an example program that takes two integers (~x~ and ~y~) from the console
and adds them (~x~ + ~y~). If the user gives non-integers it will continue to ask
until an integer is given.

#+BEGIN_SRC python
  from monad.maybe import Maybe, Just, Nothing

  def lift_input(prompt):
      text = input(prompt)
      if text:
	  return Just(text)
      return Nothing()

  def try_parse_int(s):
      try:
	  return Just(int(s))
      except ValueError:
	  return Nothing()

  def input_int(prompt):
      m = lift_input(prompt).bind(try_parse_int)
      if isinstance(m, Nothing):
	  return input_int(prompt)
      return m

  input_int('X = ') \
      .bind(lambda x: input_int('Y = ').bind(lambda y: Maybe.lift(x + y))) \
      .fmap(lambda sum: print('X + Y = ' + str(sum)))
#+END_SRC
** Either
** Reader
